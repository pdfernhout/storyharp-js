begin TO {

end; TO }

:= TO =

self. TO this.

' TO "

result = TO return
EXCEPT may be using that as an intermediate variable...
IN WHICH CASE "let result" and then at end "return result"

{ } TO //
BY REGEX: {(.*)} TO // $1

FIX if ... then
BY REGEX: if (.*) then TO if ($1)

<> TO !==

:= TO =

nil TO null
but may also be undefined...

====
class definition
remove prefix on procedures and functions
EXAMPLE REGEX procedure KfCommandList\.(.*); TO $1(): void

procedures GET empty () added

enums GET enum Type = { one, two, three }


while do TO while {

TList TO []
list.count TO list.length

and TO &&

dec(X) TO X--

case of class names may not be correct
; TO , IN function parameters

REGEX ;\n TO \n

SEARCH for possible procedure calls without parens:
\.[^(]


======

Automated conversion:

Some type delcarations get confused with variable delclarations: 
   TSVariableDisplayOptions = boolean[] /* 5 + 1 */
Should be:
   export type TSVariableDisplayOptions = boolean[] /* 5 + 1 */


When you assign records with "=" like "a = b", Delphi implicitly does a copy from record to record.
If the records are replaced by objects, to be safe,
you should assign a with a new object that is a copy of b.
Otherwise, modifications of a would affect b.

Cooments don;t always end up in the right place.
Typically they may be a bit lower inside a section if they were before a section.
But they may also be quite a bit lower in a following section.

TODO Fix TS Inheritance:
    TSVariable.prototype = new TSDraggableObject()
    TSVariable.prototype.constructor = TSVariable 

TODO: do not add "// const"

TODO: switch statement missing final closing brace "}"

for functions that return a result, typically redundant code that can be delete.
Use let or const later in the function's code to clean things up.

TODO: enum variables with be delclared with a new of the type.
  state: TSVariableState = new TSVariableState()

Convert TList to native array. But should add type to the array.
Might want to consider emulating Delphi array if had a lot of them.

Need to reason about destroy methods before deletign them (or renaming them).
They may need to be called manually if they have larger side effects like reference counting.
Suggest adding "Manually" at end in such cases to have "destroyManually" and then calling it when needed.
You would need to change ".free" to ".destroyManually()" in such cases.

Delphi type casts need to be removed or converted. Example:
   TSDesiredStateVariableWrapper(this.requirements[i]).variable.requirementsUseages -= 1
after delcaring: requirements: TSDesiredStateVariableWrapper[] = []
   this.requirements[i].variable.requirementsUseages -= 1

Delphi strings are 1-based not 0-based!!!

Failed to put string as return type instead of void:
   recordReplyMoveChanges(changedVariablesList: TSChangedVariableWrapper[], totalReply: string, contextToFocusTo: TSVariable): void
Maybe got confused by needing manual fixup for assignment to a parameter?

TODO: eed to handle super calls better for TS:
  TSDraggableObject.prototype.setPosition.call(this, firstPart)
